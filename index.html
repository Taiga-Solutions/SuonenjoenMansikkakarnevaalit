<!DOCTYPE html>
<html lang="fi">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Suonenjoki 3D - Tarkka Fysiikka</title>
    <style>
        body { margin: 0; overflow: hidden; background: #87CEEB; font-family: 'Segoe UI', sans-serif; }
        
        #ui-layer {
            position: absolute; top: 10px; left: 10px; z-index: 10;
            color: white; text-shadow: 2px 2px 0 #000;
        }
        h1 { margin: 0; font-size: 20px; color: #ffeb3b; }
        .stat { font-size: 24px; font-weight: bold; }
        
        #loading {
            position: absolute; top: 50%; left: 50%; transform: translate(-50%, -50%);
            background: rgba(0,0,0,0.9); color: white; padding: 30px; border-radius: 10px;
            text-align: center; z-index: 100; box-shadow: 0 0 20px rgba(0,0,0,0.5);
        }
        
        #game-over {
            position: absolute; top: 50%; left: 50%; transform: translate(-50%, -50%);
            background: #fff; padding: 40px; border-radius: 20px; text-align: center;
            border: 5px solid #d32f2f; display: none; z-index: 200; min-width: 300px;
        }
        #end-reason { font-size: 22px; font-weight: bold; margin-bottom: 10px; display:block; }
        button {
            background: #d32f2f; color: white; border: none; padding: 12px 30px;
            font-size: 18px; cursor: pointer; border-radius: 5px; margin-top: 15px;
        }
        button:hover { background: #b71c1c; }

        #osm-credit {
            position: absolute; bottom: 5px; right: 5px; font-size: 10px;
            background: rgba(255,255,255,0.7); padding: 2px 5px; pointer-events: auto; z-index: 5;
        }
    </style>
</head>
<body>

    <div id="ui-layer">
        <h1>üçì Mansikkakarnevaali 2026</h1>
        <div class="stat">Pisteet: <span id="score">0</span> / 40</div>
        <div style="font-size: 14px; margin-top:5px;">Varo r√§k√§ttirastaita ja seini√§!</div>
    </div>

    <div id="loading">
        <h2>Ladataan Suonenjokea...</h2>
        <div id="loading-text">Rakennetaan tarkkaa 3D-kaupunkia...</div>
    </div>

    <div id="game-over">
        <span id="end-reason">SYY</span>
        <p>Ker√§sit <span id="final-score">0</span> mansikkaa.</p>
        <button onclick="location.reload()">Yrit√§ Uudestaan</button>
    </div>

    <div id="osm-credit">¬© OpenStreetMap contributors</div>
    <div id="canvas-container"></div>

    <script type="importmap">
        { "imports": { "three": "https://unpkg.com/three@0.160.0/build/three.module.js" } }
    </script>

    <script type="module">
        import * as THREE from 'three';

        // --- ASETUKSET ---
        const ORIGIN_LAT = 62.6255;
        const ORIGIN_LON = 27.1245;
        const ZOOM = 16; 
        const TILE_RANGE = 2; 

        let scene, camera, renderer, car;
        let strawberries = [];
        let birds = []; 
        let buildingMeshes = []; // Tallennetaan meshit raycastingia varten
        
        let keys = { w:0, a:0, s:0, d:0 };
        let speed = 0, angle = 0;
        let worldCenter = { x: 0, y: 0 };
        let gameActive = false;
        let score = 0;
        
        // Raycaster t√∂rm√§yksi√§ varten
        const raycaster = new THREE.Raycaster();

        // Projektiofunktiot
        function project(lat, lon) {
            const R = 6378137;
            const x = R * (lon * Math.PI / 180);
            const y = R * Math.log(Math.tan(Math.PI / 4 + (lat * Math.PI / 180) / 2));
            return { x: x, y: y };
        }
        function tileToLatLon(x, y, z) {
            const n = Math.pow(2, z);
            const lon_deg = x / n * 360.0 - 180.0;
            const lat_rad = Math.atan(Math.sinh(Math.PI * (1 - 2 * y / n)));
            const lat_deg = lat_rad * 180.0 / Math.PI;
            return { lat: lat_deg, lon: lon_deg };
        }
        function lon2tile(lon,zoom) { return (Math.floor((lon+180)/360*Math.pow(2,zoom))); }
        function lat2tile(lat,zoom) { return (Math.floor((1-Math.log(Math.tan(lat*Math.PI/180) + 1/Math.cos(lat*Math.PI/180))/Math.PI)/2 *Math.pow(2,zoom))); }

        // --- ALUSTUS ---
        function init() {
            scene = new THREE.Scene();
            scene.background = new THREE.Color(0x87CEEB);
            scene.fog = new THREE.Fog(0x87CEEB, 20, 300);

            camera = new THREE.PerspectiveCamera(60, window.innerWidth/window.innerHeight, 0.1, 1000);
            camera.position.set(0, 30, 40);

            renderer = new THREE.WebGLRenderer({ antialias: true });
            renderer.setSize(window.innerWidth, window.innerHeight);
            renderer.shadowMap.enabled = true;
            document.getElementById('canvas-container').appendChild(renderer.domElement);

            // Valot
            const amb = new THREE.AmbientLight(0xffffff, 0.6);
            scene.add(amb);
            const sun = new THREE.DirectionalLight(0xffffff, 0.8);
            sun.position.set(50, 100, 50);
            sun.castShadow = true;
            sun.shadow.camera.left = -200; sun.shadow.camera.right = 200;
            sun.shadow.camera.top = 200; sun.shadow.camera.bottom = -200;
            sun.shadow.mapSize.width = 2048; sun.shadow.mapSize.height = 2048;
            scene.add(sun);

            worldCenter = project(ORIGIN_LAT, ORIGIN_LON);

            createAccurateMap();
            fetchBuildings(); 
            createCar();

            window.addEventListener('keydown', e => updateKey(e.key, 1));
            window.addEventListener('keyup', e => updateKey(e.key, 0));
            window.addEventListener('resize', onResize);

            animate();
        }

        function updateKey(k, v) {
            const key = k.toLowerCase();
            if(key==='w'||key==='arrowup') keys.w=v;
            if(key==='s'||key==='arrowdown') keys.s=v;
            if(key==='a'||key==='arrowleft') keys.a=v;
            if(key==='d'||key==='arrowright') keys.d=v;
        }

        // --- KARTTA & RAKENNUKSET ---
        function createAccurateMap() {
            const centerTileX = lon2tile(ORIGIN_LON, ZOOM);
            const centerTileY = lat2tile(ORIGIN_LAT, ZOOM);
            const range = TILE_RANGE;
            
            const minTX = centerTileX - range, maxTX = centerTileX + range;
            const minTY = centerTileY - range, maxTY = centerTileY + range;
            
            const tileW = (maxTX - minTX + 1);
            const tileH = (maxTY - minTY + 1);
            const px = 256;

            const canvas = document.createElement('canvas');
            canvas.width = tileW * px; canvas.height = tileH * px;
            const ctx = canvas.getContext('2d');
            ctx.fillStyle = '#ddd'; ctx.fillRect(0,0,canvas.width,canvas.height);

            const tex = new THREE.CanvasTexture(canvas);
            tex.colorSpace = THREE.SRGBColorSpace;
            tex.anisotropy = 4;

            let loaded = 0;

            for(let x=0; x<tileW; x++) {
                for(let y=0; y<tileH; y++) {
                    const img = new Image();
                    img.crossOrigin = "anonymous";
                    img.src = `https://tile.openstreetmap.org/${ZOOM}/${minTX+x}/${minTY+y}.png`;
                    img.onload = () => {
                        ctx.drawImage(img, x*px, y*px);
                        tex.needsUpdate = true;
                        loaded++;
                    };
                }
            }

            const tlLL = tileToLatLon(minTX, minTY, ZOOM);
            const brLL = tileToLatLon(maxTX+1, maxTY+1, ZOOM);
            const tl = project(tlLL.lat, tlLL.lon);
            const br = project(brLL.lat, brLL.lon);
            
            const w = Math.abs(br.x - tl.x);
            const h = Math.abs(tl.y - br.y);
            const plane = new THREE.Mesh(
                new THREE.PlaneGeometry(w, h),
                new THREE.MeshStandardMaterial({ map: tex, roughness: 1 })
            );
            plane.rotation.x = -Math.PI/2;
            
            const midX = (tl.x + br.x)/2;
            const midY = (tl.y + br.y)/2;
            plane.position.x = midX - worldCenter.x;
            plane.position.z = -1 * (midY - worldCenter.y);
            plane.receiveShadow = true;
            scene.add(plane);
        }

        async function fetchBuildings() {
            const bounds = 0.008;
            const bbox = `${ORIGIN_LAT - bounds},${ORIGIN_LON - bounds},${ORIGIN_LAT + bounds},${ORIGIN_LON + bounds}`;
            const query = `[out:json][timeout:25];(way["building"](${bbox}); relation["building"](${bbox}););out body;>;out skel qt;`;

            try {
                const res = await fetch('https://overpass-api.de/api/interpreter', { method:'POST', body:query });
                const data = await res.json();
                buildCity(data);
                spawnGameObjects();
                
                document.getElementById('loading').style.display = 'none';
                gameActive = true;
            } catch(e) {
                document.getElementById('loading-text').innerText = "Virhe karttadatassa. Lataa sivu uudelleen.";
            }
        }

        function buildCity(data) {
            const nodes = {};
            data.elements.forEach(e => { if(e.type==='node') nodes[e.id] = {lat:e.lat, lon:e.lon}; });

            const wallMat = new THREE.MeshStandardMaterial({ color: 0xeeeeee });
            const roofMat = new THREE.MeshStandardMaterial({ color: 0x8d6e63 });

            data.elements.forEach(el => {
                if(el.type === 'way' && el.nodes && el.nodes.length > 2) {
                    const shape = new THREE.Shape();
                    const pts = [];
                    for(let i=0; i<el.nodes.length; i++) {
                        const n = nodes[el.nodes[i]];
                        if(!n) continue;
                        const p = project(n.lat, n.lon);
                        pts.push({ x: p.x - worldCenter.x, z: -1 * (p.y - worldCenter.y) });
                    }
                    if(pts.length < 3) return;
                    
                    shape.moveTo(pts[0].x, pts[0].z);
                    for(let i=1; i<pts.length; i++) shape.lineTo(pts[i].x, pts[i].z);

                    let h = 6; 
                    if(el.tags && el.tags['building:levels']) h = parseInt(el.tags['building:levels']) * 4;

                    const geom = new THREE.ExtrudeGeometry(shape, { depth: h, bevelEnabled: false });
                    geom.rotateX(Math.PI / 2);
                    geom.translate(0, h, 0);

                    const mesh = new THREE.Mesh(geom, [roofMat, wallMat]);
                    mesh.castShadow = true;
                    mesh.receiveShadow = true;
                    scene.add(mesh);
                    
                    // Lis√§t√§√§n mesh listaan tarkkaa t√∂rm√§ystarkistusta varten
                    buildingMeshes.push(mesh);
                }
            });
        }

        // --- PELIOBJEKTIT ---
        function createCar() {
            car = new THREE.Group();
            
            // Runko
            const chassi = new THREE.Mesh(new THREE.BoxGeometry(1.5, 0.7, 3.2), new THREE.MeshStandardMaterial({ color: 0xd32f2f }));
            chassi.position.y = 0.7; chassi.castShadow=true;
            car.add(chassi);
            
            // Katto
            const top = new THREE.Mesh(new THREE.BoxGeometry(1.4, 0.6, 1.8), new THREE.MeshStandardMaterial({ color: 0xffffff }));
            top.position.set(0, 1.4, -0.3); top.castShadow=true;
            car.add(top);

            // Renkaat
            const wGeo = new THREE.CylinderGeometry(0.35, 0.35, 0.3, 12);
            const wMat = new THREE.MeshStandardMaterial({ color: 0x333 });
            [[-0.9, 1.1], [0.9, 1.1], [-0.9, -1.1], [0.9, -1.1]].forEach(p => {
                const w = new THREE.Mesh(wGeo, wMat);
                w.rotation.z = Math.PI/2; w.position.set(p[0], 0.35, p[1]);
                car.add(w);
            });

            scene.add(car);
        }

        function createBird() {
            const bird = new THREE.Group();
            
            const body = new THREE.Mesh(new THREE.ConeGeometry(0.25, 0.8, 8), new THREE.MeshLambertMaterial({color: 0x555555}));
            body.rotation.x = Math.PI / 2;
            bird.add(body);

            const wingGeo = new THREE.BoxGeometry(1.2, 0.05, 0.4);
            const wingMat = new THREE.MeshLambertMaterial({color: 0x333333});
            const wings = new THREE.Mesh(wingGeo, wingMat);
            wings.position.y = 0.1;
            bird.add(wings);

            bird.userData = { 
                wings: wings, 
                speed: 0.1 + Math.random() * 0.05,
                phase: Math.random() * 10
            };
            return bird;
        }

        function spawnGameObjects() {
            for(let i=0; i<40; i++) {
                const g = new THREE.Group();
                const m = new THREE.Mesh(new THREE.ConeGeometry(0.5,1,8), new THREE.MeshLambertMaterial({color:0xff0000}));
                m.rotation.x = Math.PI; m.position.y=1;
                const l = new THREE.Mesh(new THREE.DodecahedronGeometry(0.3), new THREE.MeshLambertMaterial({color:0x00aa00}));
                l.position.y=1.5; l.scale.y=0.3;
                g.add(m); g.add(l);
                
                const a = Math.random()*Math.PI*2;
                const r = 20 + Math.random()*200;
                g.position.set(Math.cos(a)*r, 0, Math.sin(a)*r);
                g.userData = { y:0, off:Math.random() };
                
                scene.add(g);
                strawberries.push(g);
            }

            for(let i=0; i<10; i++) {
                const bird = createBird();
                const a = Math.random()*Math.PI*2;
                const r = 50 + Math.random()*200;
                bird.position.set(Math.cos(a)*r, 5 + Math.random()*5, Math.sin(a)*r);
                scene.add(bird);
                birds.push(bird);
            }
        }

        // --- TARKKA RAYCASTING T√ñRM√ÑYS ---
        function checkCollisions() {
            if(!car) return;
            const carPos = car.position;

            // 1. RAKENNUST√ñRM√ÑYS (S√§teenseuranta / Raycasting)
            // Ammutaan s√§teit√§ autosta eri suuntiin. Jos joku osuu l√§helle, on t√∂rm√§ys.
            // N√§in laatikon k√§√§ntyminen ei aiheuta haamuseini√§.
            
            // M√§√§ritell√§√§n s√§teiden suunnat (Eteen, taakse, viistot)
            const directions = [
                new THREE.Vector3(0, 0, 1),   // Eteen
                new THREE.Vector3(0, 0, -1),  // Taakse
                new THREE.Vector3(1, 0, 1).normalize(),  // Oikea etuviisto
                new THREE.Vector3(-1, 0, 1).normalize(), // Vasen etuviisto
                new THREE.Vector3(1, 0, 0),   // Oikealle
                new THREE.Vector3(-1, 0, 0)   // Vasemmalle
            ];

            // Optimointi: Tarkistetaan vain l√§hell√§ olevat talot (alle 30m)
            const nearbyBuildings = buildingMeshes.filter(b => b.position.distanceToSquared(carPos) < 900); // 30*30 = 900

            if (nearbyBuildings.length > 0) {
                for(let dir of directions) {
                    // K√§√§nn√§ suuntavektori auton suunnan mukaiseksi
                    const rotatedDir = dir.clone().applyAxisAngle(new THREE.Vector3(0,1,0), car.rotation.y);
                    
                    // Aseta s√§de: Alkaa auton keskelt√§ (hieman maanpinnan yl√§puolelta), osoittaa suuntaan
                    raycaster.set(new THREE.Vector3(carPos.x, 1, carPos.z), rotatedDir);
                    
                    // Tarkista osumat
                    const intersects = raycaster.intersectObjects(nearbyBuildings);
                    
                    // Jos osuu johonkin ja et√§isyys on pieni (auto on n. 1.5m leve√§, joten < 1.2 on osuma)
                    if (intersects.length > 0 && intersects[0].distance < 1.3) {
                        endGame("AJOIT SEIN√Ñ√ÑN!", "#d32f2f");
                        return;
                    }
                }
            }

            // 2. MANSIKAT
            for(let i=strawberries.length-1; i>=0; i--) {
                const s = strawberries[i];
                if(carPos.distanceTo(s.position) < 3) {
                    scene.remove(s);
                    strawberries.splice(i, 1);
                    score++;
                    document.getElementById('score').innerText = score;
                    if(strawberries.length === 0) endGame("MANSIKKAMESTARI! VOITIT!", "green");
                }
            }

            // 3. R√ÑK√ÑTTIRASTAAT
            for(let bird of birds) {
                const dir = new THREE.Vector3().subVectors(carPos, bird.position);
                dir.y = 0; dir.normalize();
                
                bird.position.add(dir.multiplyScalar(bird.userData.speed));
                bird.lookAt(carPos.x, bird.position.y, carPos.z);
                bird.userData.wings.rotation.z = Math.sin(Date.now() * 0.02 + bird.userData.phase) * 0.5;

                const flatDist = new THREE.Vector2(bird.position.x, bird.position.z).distanceTo(new THREE.Vector2(carPos.x, carPos.z));
                if(flatDist < 25) {
                     bird.position.y = THREE.MathUtils.lerp(bird.position.y, 1.5, 0.03);
                } else {
                     bird.position.y = THREE.MathUtils.lerp(bird.position.y, 8, 0.01);
                }

                if(bird.position.distanceTo(carPos) < 2.5) {
                    endGame("R√ÑK√ÑTTIRASTAS NAPPASI!", "#555");
                    return;
                }
            }
        }

        function endGame(msg, color) {
            gameActive = false;
            document.getElementById('end-reason').innerText = msg;
            document.getElementById('end-reason').style.color = color;
            document.getElementById('final-score').innerText = score;
            document.getElementById('game-over').style.display = 'block';
        }

        function animate() {
            requestAnimationFrame(animate);

            if(gameActive && car) {
                // Auto
                if(keys.w) speed += 0.04;
                if(keys.s) speed -= 0.04;
                speed *= 0.96; 
                
                if(Math.abs(speed)>0.1) {
                    const dir = speed>0?1:-1;
                    if(keys.a) angle += 0.05 * dir;
                    if(keys.d) angle -= 0.05 * dir;
                }
                
                car.rotation.y = angle;
                car.position.x += Math.sin(angle)*speed;
                car.position.z += Math.cos(angle)*speed;

                const camOff = new THREE.Vector3(0, 15, -20).applyMatrix4(car.matrixWorld);
                camera.position.lerp(camOff, 0.1);
                camera.lookAt(car.position);

                strawberries.forEach(s => {
                    s.rotation.y += 0.02;
                    s.position.y = 1 + Math.sin(Date.now()*0.003 + s.userData.off)*0.3;
                });

                checkCollisions();
            }
            renderer.render(scene, camera);
        }

        function onResize() {
            camera.aspect = window.innerWidth/window.innerHeight;
            camera.updateProjectionMatrix();
            renderer.setSize(window.innerWidth, window.innerHeight);
        }

        init();
    </script>
</body>
</html>
